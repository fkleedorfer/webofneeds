import {
  isValidDate,
  parseDatetimeStrictly,
  toLocalISODateString,
} from "../../app/utils.js";
import * as jsonLdUtils from "../../app/service/jsonld-utils.js";
import WonDateTimeViewer from "../../app/components/details/viewer/datetime-viewer.jsx";
import WonDateTimePicker from "../../app/components/details/picker/datetime-picker.jsx";
import WonDateTimeRangePicker from "../../app/components/details/picker/datetime-range-picker.jsx";

import ico36_detail_datetime from "../../images/won-icons/ico36_detail_datetime.svg";

export const fromDatetime = {
  identifier: "fromDatetime",
  label: "Starting at",
  icon: ico36_detail_datetime,
  placeholder: "Enter Date and Time...",
  component: WonDateTimePicker,
  viewerComponent: WonDateTimeViewer,
  messageEnabled: true,
  parseToRDF: function({ value }) {
    // value can be an xsd:datetime-string or a javascript date object
    const datetime = parseDatetimeStrictly(value);
    if (!isValidDate(datetime)) {
      return { "s:validFrom": undefined };
    } else {
      const datetimeString = toLocalISODateString(datetime);
      return {
        "s:validFrom": { "@value": datetimeString, "@type": "xsd:dateTime" },
      };
    }
  },
  parseFromRDF: function(jsonLDImm) {
    return jsonLdUtils.parseFrom(jsonLDImm, ["s:validFrom"], "xsd:dateTime");
  },
  generateHumanReadable: function({ value, includeLabel }) {
    if (value) {
      const maybeLabel = includeLabel ? this.label + ": " : "";
      const datetime = parseDatetimeStrictly(value);
      const timestring = isValidDate(datetime) ? datetime.toLocaleString() : "";
      return maybeLabel + timestring;
    }
    return undefined;
  },
};

export const throughDatetime = {
  identifier: "throughDatetime",
  label: "Ending at",
  icon: ico36_detail_datetime,
  placeholder: "Enter Date and Time...",
  component: WonDateTimePicker,
  viewerComponent: WonDateTimeViewer,
  messageEnabled: true,
  parseToRDF: function({ value }) {
    // value can be an xsd:datetime-string or a javascript date object
    const datetime = parseDatetimeStrictly(value);
    if (!isValidDate(datetime)) {
      return { "s:validThrough": undefined };
    } else {
      const datetimeString = toLocalISODateString(datetime);
      return {
        "s:validThrough": {
          "@value": datetimeString,
          "@type": "xsd:dateTime",
        },
      };
    }
  },
  parseFromRDF: function(jsonLDImm) {
    return jsonLdUtils.parseFrom(jsonLDImm, ["s:validThrough"], "xsd:dateTime");
  },
  generateHumanReadable: function({ value, includeLabel }) {
    if (value) {
      const maybeLabel = includeLabel ? this.label + ": " : "";
      const datetime = parseDatetimeStrictly(value);
      const timestring = isValidDate(datetime) ? datetime.toLocaleString() : "";
      return maybeLabel + timestring;
    }
    return undefined;
  },
};

export const datetimeRange = {
  identifier: "datetimeRange",
  label: "Timerange",
  icon: ico36_detail_datetime,
  placeholder: undefined,
  component: WonDateTimeRangePicker,
  viewerComponent: WonDateTimeViewer,
  messageEnabled: false,
  parseToRDF: function({ value }) {
    if (value) {
      const fromDatetime = parseDatetimeStrictly(value.fromDatetime);
      const toDatetime = parseDatetimeStrictly(value.toDatetime);

      let validFrom = undefined;
      let validThrough = undefined;

      if (isValidDate(fromDatetime)) {
        const fromDatetimeString = toLocalISODateString(fromDatetime);
        validFrom = {
          "@value": fromDatetimeString,
          "@type": "xsd:dateTime",
        };
      }

      if (isValidDate(toDatetime)) {
        const toDatetimeString = toLocalISODateString(toDatetime);
        validThrough = {
          "@value": toDatetimeString,
          "@type": "xsd:dateTime",
        };
      }

      return {
        "s:validFrom": validFrom,
        "s:validThrough": validThrough,
      };
    } else {
      return {
        "s:validFrom": undefined,
        "s:validThrough": undefined,
      };
    }
  },
  parseFromRDF: function() {}, // RDF should be parsed by fromDatetime and throughDatetime
  generateHumanReadable: function() {}, // should be generated by fromDatetime and troughDatetime
};
