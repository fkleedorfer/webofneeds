@prefix dfc:     <http://www.virtual-assembly.org/DataFoodConsortium/BusinessOntology#> .
@prefix owl:     <http://www.w3.org/2002/07/owl#> .
@prefix org:     <http://www.w3.org/ns/org#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .
@prefix dtype:   <http://www.linkedmodel.org/schema/dtype#> .
@prefix skos:    <http://www.w3.org/2004/02/skos/core#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
@prefix geo:     <http://www.w3.org/2003/01/geo/wgs84_pos#> .
@prefix vf:      <https://w3id.org/valueflows#> .
@prefix sh:      <http://www.w3.org/ns/shacl#> .
@prefix om2:     <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix time:    <http://www.w3.org/2006/time#> .
@prefix vs:      <http://www.w3.org/2003/06/sw-vocab-status/ns#> .
@prefix foaf:    <http://xmlns.com/foaf/0.1/> .
@prefix om2:     <http://www.ontology-of-units-of-measure.org/resource/om-2/> .
@prefix :        <https://w3id.org/valueflows-shacl/shapes#> .
@prefix vfs:     <https://w3id.org/valueflows-shacl/shapes#> .
@prefix ex:      <http://example.org/ns#> .
@prefix fn:      <https://w3id.org/shacl-commons/functions#> .
@prefix bl:      <https://w3id.org/won/blending#> .



# Note: more info on validation rules:
#
# https://github.com/valueflows/vf-apps/issues/5
#


vf:
    sh:declare [ sh:prefix    "om2" ;
                 sh:namespace "http://www.ontology-of-units-of-measure.org/resource/om-2/" ; ] ;
    sh:declare [ sh:prefix    "vf" ;
                 sh:namespace "https://w3id.org/valueflows#" ; ] ;
    sh:declare [ sh:prefix    "bl" ;
                 sh:namespace "https://w3id.org/won/blending#" ; ] ;
    sh:declare [ sh:prefix    "vfs" ;
                 sh:namespace "https://w3id.org/valueflows-shacl/shapes#" ; ] ;
    sh:declare [ sh:prefix    "fn" ;
                 sh:namespace "https://w3id.org/shacl-commons/functions#" ; ] ;
    sh:declare [ sh:prefix    "owl" ;
                 sh:namespace "http://www.w3.org/2002/07/owl#" ; ] ;
    sh:declare [ sh:prefix    "rdf" ;
                 sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ; ] ;
    sh:declare [ sh:prefix    "xsd" ;
                 sh:namespace "http://www.w3.org/2001/XMLSchema#" ; ] ;
.


# Adaptations to original vf ontology:
# - new vf:toLocation property to express moving resources


:EconomicEventShape
    a              sh:NodeShape ;
    sh:targetClass vf:EconomicEvent ;
    sh:property    :ProviderRequiredShape ;
    sh:property    :ReceiverRequiredShape ;
    sh:property    :ActionRequiredShape ;
    sh:property    :ResourceInventoriedAsShape ;
    sh:property    :ToResourceInventoriedAsShape ;
    sh:property    :AtLocationShape ;
    sh:xone        ( [ sh:property :ResourceQuantityRequiredShape ]
                     [ sh:property :EffortQuantityRequiredShape ; ] ) ;
    sh:property    :ResourceClassifiedAsShape ;
.

:EconomicEventCandidateShape
    a              sh:NodeShape .

# drop all solutions in which provider = receiver

ex:providerDiffersFromReceiverShape
    a             sh:NodeShape ;
    sh:targetClass vf:Intent, vf:Commitment, vf:EconomicEvent ;
    sh:not        [ sh:path     vf:provider ;
                    sh:equals   vf:receiver ;
                    sh:message "vf:provider and vf:receiver must be different" ;
                    sh:maxCount 1 ;
                    sh:minCount 1 ; ] .

# drop all solutions in which resource = toResource

ex:resourceDiffersFromToResourceShape
    a             sh:NodeShape ;
    sh:targetClass vf:Intent, vf:Commitment, vf:EconomicEvent ;
    sh:property [
                  sh:path vf:resourceInventoriedAs ;
                  sh:minCount 1 ;
                  sh:maxCount 1 ;
                ] ;
    sh:property [
                  sh:path vf:toResourceInventoriedAs ;
                  sh:minCount 1 ;
                  sh:maxCount 1 ;
    ] ;
    sh:not        [ sh:path     vf:resourceInventoriedAs ;
                    sh:equals   vf:toResourceInventoriedAs ;
                    sh:message "vf:resource and vf:toResource must be different" ;
                    sh:maxCount 1 ;
                    sh:minCount 1 ; ] .

:quantityFullyBlendedOrNotAtAll
    a                  sh:NodeShape ;
    sh:targetObjectsOf vf:resourceQuantity, vf:onhandQuantity, vf:accountingQuantity, vf:effortQuantity ;
    sh:sparql          [ a           sh:SPARQLConstraint ;
                         sh:message  "Both om2:hasNumericalValue and om2:hasUnit must be merged or neither!" ;
                         sh:prefixes vf:, bl:, om2:, fn: ;
                         sh:select   """SELECT $this
                  WHERE {
                    $this om2:hasUnit ?unit ;
                          om2:hasNumericalValue ?value .
                    optional {
                        ?unit a bl:Variable
                        bind(true as ?unitUnbound)
                    }
                    optional {
                        ?value a bl:Variable
                        bind(true as ?valueUnbound)
                    }
                    filter ( ! fn:xoneBound(?unitUnbound, ?valueUnbound) )
                  }""" ; ] .


:IntentShape
    a           sh:NodeShape ;
    sh:targetClass vf:Intent ;
    sh:property :ProviderRequiredShape ;
    sh:property :ReceiverRequiredShape ;
    sh:property :ActionRequiredShape ;
    sh:property :ResourceInventoriedAsShape ;
    sh:property :ToResourceInventoriedAsShape ;
    sh:xone     ( [ sh:property :ResourceQuantityRequiredShape ]
                  [ sh:property :EffortQuantityRequiredShape ; ] ) ;
    sh:property :ResourceClassifiedAsRequiredShape ;
.

:IntentCandidateShape
    a           sh:NodeShape ;
    sh:targetClass vf:Intent ;
    sh:deactivated true .

:RecipeFlowShape
    a           sh:NodeShape ;
    sh:targetClass vf:RecipeFlow ;
    sh:property :ProviderShape ;
    sh:property :ReceiverShape ;
    sh:property :ActionRequiredShape ;
    sh:xone     ( [ sh:property :ResourceQuantityRequiredShape ]
                  [ sh:property :EffortQuantityRequiredShape ; ] ) ;
.

:RecipeFlowCandidateShape
    a           sh:NodeShape ;
    sh:targetClass vf:RecipeFlow ;
    sh:deactivated true .

:CommitmentShape
    a           sh:NodeShape ;
    sh:targetClass vf:Commitment ;
    sh:property :ProviderRequiredShape ;
    sh:property :ReceiverRequiredShape ;
    sh:property :ActionRequiredShape ;
    sh:property :ResourceInventoriedAsShape ;
    sh:property :ToResourceInventoriedAsShape ;
    sh:xone     ( [ sh:property :ResourceQuantityRequiredShape ; ]
                  [ sh:property :EffortQuantityRequiredShape ; ] ) ;
    sh:property :ResourceClassifiedAsShape ;
    sh:property [ sh:path     [ sh:inversePath vf:satisfiedBy ] ;
                  sh:minCount 1 ; ] ;
.

:CommitmentCandidateShape
    a           sh:NodeShape ;
    sh:targetClass vf:Commitment ;
    sh:deactivated true .

:SatisfactionShape
    a           sh:NodeShape ;
    sh:targetClass  vf:Satisfaction ;
    sh:property :ResourceQuantityRequiredShape ;
    sh:property [ sh:path     vf:satisfies ;
                  sh:class    vf:Intent ;
                  sh:minCount 1 ; ] ;
    sh:property [ sh:path     vf:satisfiedBy ;
                  sh:class    vf:Commitment ;
                  sh:minCount 1 ; ] ;
.

:SatisfactionCandidateShape
    a           sh:NodeShape ;
    sh:targetClass  vf:Satisfaction ;
    sh:deactivated true .

:EconomicResourceShape
    a              sh:NodeShape ;
    sh:targetClass vf:EconomicResource ;
    sh:property    :AccountingQuantityShape ;
    sh:property    :OnhandQuantityShape ;
    sh:property    :ClassifiedAsShape ;
    sh:property    :TrackingIdentifierShape ;
    sh:property    :ConformsToShape ;
    sh:property    :ContainedInShape ;
    sh:property    :CurrentLocationShape ;
    sh:property    :PrimaryAccountableShape ;
# ignoring for now:
#       sh:property     :lotShape ; unclear: what is product batch?
#       sh:property     :stageShape ;
#       sh:property     :stateShape ;
#       sh:property     :TrackingIdentifierShape ;
.

:EconomicResourceCandidateShape
    a              sh:NodeShape ;
    sh:targetClass vf:EconomicResource ;
    sh:deactivated true .

:ResourceClassCandidateShape a sh:NodeShape ;
    sh:targetObjectsOf vf:classifiedAs ;
    sh:targetObjectsOf vf:resourceClassifiedAs ;
    sh:targetObjectsOf vf:toResourceClassifiedAs .


:PrimaryAccountableShape
    a           sh:PropertyShape ;
    sh:path     vf:primaryAccountable ;
    sh:targetSubjectsOf     vf:primaryAccountable ;
    sh:class    foaf:Agent ;
    sh:maxCount 1 ;
.

:LocationCandidateShape a sh:NodeShape ;
    sh:targetObjectsOf vf:atLocation ;
    sh:targetObjectsOf vf:toLocation ;
    sh:targetObjectsOf vf:currentLocation ;
    sh:targetObjectsOf vf:elegibleLocation ;
       sh:targetObjectsOf vf:primaryLocation ;
                        sh:deactivated true .

:AtLocationShape
    a           sh:PropertyShape ;
    sh:path     vf:atLocation ;
    sh:targetSubjectsOf     vf:atLocation ;
    sh:maxCount 1 ;
.

:AtLocationRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:atLocation ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
.

:ToLocationShape
    a           sh:PropertyShape ;
    sh:path     vf:toLocation ;
    sh:targetSubjectsOf     vf:toLocation ;
    sh:maxCount 1 ;
.

:ToLocationRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:toLocation ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
.

:CurrentLocationShape
    a           sh:PropertyShape ;
    sh:path     vf:currentLocation ;
    sh:targetSubjectsOf     vf:currentLocation ;
    sh:nodeKind sh:IRI ;
    sh:maxCount 1 ;
.

:ConformsToShape
    a        sh:PropertyShape ;
    sh:path  vf:conformsTo ;
    sh:targetSubjectsOf  vf:conformsTo ;
    sh:class vf:ResourceSpecification ;
.

:ContainedInShape
    a        sh:PropertyShape ;
    sh:path  vf:containedIn ;
    sh:targetSubjectsOf  vf:containedIn ;
    sh:class vf:EconomicResource ;
.

:TrackingIdentifierShape
    a           sh:PropertyShape ;
    sh:path     vf:trackingIdentifier ;
    sh:targetSubjectsOf     vf:trackingIdentifier ;
    sh:nodeKind sh:IRIOrLiteral ;
    sh:maxCount 1 ;
.

:ResourceClassifiedAsShape
    a           sh:PropertyShape ;
    sh:targetSubjectsOf vf:resourceClassifiedAs;
    sh:path     vf:resourceClassifiedAs ;
    sh:nodeKind sh:IRI ;
    sh:maxCount 1 ;
.


:ResourceClassifiedAsRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:resourceClassifiedAs ;
    sh:nodeKind sh:IRI ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
.

:ClassifiedAsShape
    a           sh:PropertyShape ;
    sh:path     vf:classifiedAs ;
    sh:targetSubjectsOf     vf:classifiedAs ;
    sh:nodeKind sh:IRI ;
    sh:maxCount 1 ;
.

:AccountingQuantityShape
    a           sh:PropertyShape ;
    sh:path     vf:accountingQuantity ;
    sh:targetSubjectsOf vf:accountingQuantity ;
    sh:node     :QuantityNodeShape ;
    sh:maxCount 1 ;
    sh:nodeKind sh:BlankNodeOrIRI ;
.

:QuantityNodeShape
    a           sh:NodeShape ;
    sh:property [ sh:path [ sh:inversePath [ sh:alternativePath  ( vf:onhandQuantity vf:accountingQuantity vf:resourceQuantity vf:effortQuantity ) ] ] ;
                  sh:maxCount 1;
                  sh:minCount 1;
                ] ;
    sh:property [ sh:path     om2:hasUnit ;
                  sh:class om2:Unit ;
                  sh:minCount 1 ;
                  sh:maxCount 1 ; ] ;
    sh:property [ sh:path     om2:hasNumericalValue ;
                  sh:minCount 1 ;
                  sh:maxCount 1 ;
                  sh:nodeKind sh:Literal ;
                  sh:or       ( [ sh:datatype xsd:int ]
                                [ sh:datatype xsd:integer ]
                                [ sh:datatype xsd:double ]
                                [ sh:datatype xsd:float ]
                                [ sh:datatype xsd:decimal ]
                                [ sh:datatype xsd:long ]
                                [ sh:datatype xsd:short ] ) ]
.

:OnhandQuantityShape
    a           sh:PropertyShape ;
    sh:node     :QuantityNodeShape ;
    sh:targetSubjectsOf     vf:onhandQuantity ;
    sh:path     vf:onhandQuantity ;
    sh:maxCount 1 ;
    sh:nodeKind sh:BlankNodeOrIRI ;
.

:ResourceQuantityRequiredShape
    a           sh:PropertyShape ;
    sh:node     :QuantityNodeShape ;
    sh:path     vf:resourceQuantity ;
    sh:targetSubjectsOf     vf:resourceQuantity ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
.


:EffortQuantityRequiredShape
    a           sh:PropertyShape ;
    sh:node     :QuantityNodeShape ;
    sh:path     vf:effortQuantity ;
    sh:minCount 1 ;
    sh:maxCount 1 ;
.

:QuantityUnitCandidateShape a sh:NodeShape ;
    sh:targetClass om2:Unit ;
                            sh:deactivated true .

:QuantityValueCandidateShape a sh:NodeShape ;
                     sh:targetObjectsOf om2:hasNumericalValue ;
                     sh:nodeKind sh:Literal ;
                   sh:or       ( [ sh:datatype xsd:int ]
                                 [ sh:datatype xsd:integer ]
                                 [ sh:datatype xsd:double ]
                                 [ sh:datatype xsd:float ]
                                 [ sh:datatype xsd:decimal ]
                                 [ sh:datatype xsd:long ]
                                 [ sh:datatype xsd:short ] )  ;
                             sh:deactivated true .

:ResourceInventoriedAsShape
    a           sh:PropertyShape ;
    sh:class    vf:EconomicResource ;
    sh:path     vf:resourceInventoriedAs ;
    sh:targetSubjectsOf     vf:resourceInventoriedAs ;
    sh:maxCount 1 ;
.

:ToResourceInventoriedAsShape
    a           sh:PropertyShape ;
    sh:class    vf:EconomicResource ;
    sh:path     vf:toResourceInventoriedAs ;
    sh:targetSubjectsOf     vf:toResourceInventoriedAs ;
    sh:maxCount 1 ;
.

:AgentCandidateShape a sh:NodeShape ;
    sh:targetClass foaf:Agent ;
                     sh:deactivated true .

:ProviderShape
    a           sh:PropertyShape ;
    sh:path     vf:provider ;
    sh:targetSubjectsOf     vf:provider ;
    sh:class    foaf:Agent ;
    sh:maxCount 1 ;
    sh:minCount 0 ;
    sh:nodeKind sh:IRI ;
.

:ProviderRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:provider ;
    sh:class    foaf:Agent ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:nodeKind sh:IRI ;
.

:ReceiverShape
    a           sh:PropertyShape ;
    sh:path     vf:receiver ;
    sh:targetSubjectsOf     vf:receiver ;
    sh:class    foaf:Agent ;
    sh:maxCount 1 ;
    sh:minCount 0 ;
    sh:nodeKind sh:IRI ;
.

:ReceiverRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:receiver ;
    sh:class    foaf:Agent ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
    sh:nodeKind sh:IRI ;
.

:ActionRequiredShape
    a           sh:PropertyShape ;
    sh:path     vf:action ;
    sh:targetSubjectsOf     vf:action ;
    sh:class    vf:Action ;
    sh:maxCount 1 ;
    sh:minCount 1 ;
.


###############################################################################
#   Domain-independent helper functions
###############################################################################

fn:getTypedLiteralForOp2
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :in1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :in2 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    3 ;
                   sh:path     :out ;
                   sh:optional false ; ] ;
    sh:select    """
        SELECT ?outLiteral
        WHERE {
            BIND (DATATYPE(?in1) as ?in1Datatype)
            BIND (DATATYPE(?in2) as ?in2Datatype)
            BIND (IF(BOUND(?in1Datatype),
                    ?in1Datatype,
                    ?in2Datatype)
                as ?outDatatype)
            BIND (IF(BOUND(?outDatatype),
                    STRDT(STR(?out), ?outDatatype),
                    ?out)
                as ?outLiteral)
        }
    """ ;
.


# Concatenates the parameters into a one string, separated by one whitespace
# Max number of params: 10

fn:stringConcatWithSpace
    a             sh:SPARQLFunction ;
    sh:returnType xsd:string ;
    sh:parameter  [ sh:order    1 ;
                    sh:path     :arg1 ;
                    sh:optional false ; ] ;
    sh:parameter  [ sh:order    2 ;
                    sh:path     :arg2 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    3 ;
                    sh:path     :arg3 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    4 ;
                    sh:path     :arg4 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    5 ;
                    sh:path     :arg5 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    6 ;
                    sh:path     :arg6 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    7 ;
                    sh:path     :arg7 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    8 ;
                    sh:path     :arg8 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    9 ;
                    sh:path     :arg9 ;
                    sh:optional true ; ] ;
    sh:parameter  [ sh:order    10 ;
                    sh:path     :arg10 ;
                    sh:optional true ; ] ;
    sh:select     """
        SELECT (GROUP_CONCAT(?elements; SEPARATOR=" ") as ?result)
        WHERE {
            {
                BIND("all" as ?group)
                BIND(?arg1 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg2 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg3 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg4 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg5 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg6 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg7 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg8 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg9 as ?elements)
                FILTER(BOUND(?elements))
            } UNION {
                BIND("all" as ?group)
                BIND(?arg10 as ?elements)
                FILTER(BOUND(?elements))
            }
        } GROUP BY (?group)
    """ ;
.


fn:notBound
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :node ;
                   sh:optional false ; ] ;
    sh:select    """
    SELECT (!BOUND(?node) as ?result)
    WHERE {}
    """ ;
.

fn:bound
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :node ;
                   sh:optional false ; ] ;
    sh:select    """
    SELECT (BOUND(?node) as ?result)
    WHERE {}
    """ ;
.

fn:xoneBound
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:select    """
        SELECT (
            (BOUND(?op1) && !BOUND(?op2))
            || (!BOUND(?op1) && BOUND(?op2)) as ?result)
        WHERE {}
    """ ;
.

fn:allBound2
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:select    """
        SELECT (
                ( BOUND(?op1) && BOUND(?op2) )
            as ?result)
        WHERE {}
    """ ;
.

fn:allBound3
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op3 ;
                   sh:optional true ; ] ;
    sh:select    """
        SELECT
            (
                ( BOUND(?op1) && BOUND(?op2) && BOUND(?op3) )
            as ?result)
        WHERE {}
    """ ;
.

fn:allBound4
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op4 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op3 ;
                   sh:optional true ; ] ;
    sh:select    """
        SELECT
            (
                ( BOUND(?op1) && BOUND(?op2) && BOUND(?op3) && BOUND(?op4) )
            as ?result )
        WHERE {}
    """ ;
.

fn:greaterThan
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ;
                   sh:nodeKind sh:Literal ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional false ;
                   sh:nodeKind sh:Literal ; ] ;
    sh:select    """
        SELECT ( $op1 > $op2 as ?result )
        WHERE {}
    """ ;
.


fn:greaterThanOrEquals
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ;
                   sh:nodeKind sh:Literal ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional false ;
                   sh:nodeKind sh:Literal ; ] ;
    sh:select    """
        SELECT ( $op1 >= $op2 as ?result )
        WHERE {}
    """ ;
.

fn:equals
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional false ; ] ;
    sh:select    """
        SELECT ( $op1 = $op2 as ?result )
        WHERE {}
    """ ;
.

fn:or
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op3 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op4 ;
                   sh:optional true ; ] ;
    sh:select    """
    SELECT ( ?op1 || ?op2 || ?op3 || ?op4 as ?result)
    WHERE {}
    """ ;
.

fn:and
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op3 ;
                   sh:optional true ; ] ;
    sh:parameter [ sh:path     :op4 ;
                   sh:optional true ; ] ;
    sh:select    """
    SELECT ( (!BOUND(?op1) || ?op1)
          && (!BOUND(?op2) || ?op2)
          && (!BOUND(?op3) || ?op3)
          && (!BOUND(?op4) || ?op4) as ?result)
    WHERE {}
    """ ;
.

fn:xor
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:path     :op2 ;
                   sh:optional false ; ] ;
    sh:select    """
    SELECT ( ((?op1 && ! ?op2 ) || (! ?op1 && ?op2 ))  as ?result)
    WHERE {}
    """ ;
.


fn:not
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     :op1 ;
                   sh:optional false ; ] ;
    sh:select    """
    SELECT ( ! ?op1 as ?result)
    WHERE {}
    """ ;
.

fn:min
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :arg1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :arg2 ;
                   sh:optional false ; ] ;
    sh:select    """
        SELECT (IF(?arg1 < ?arg2, ?arg1, ?arg2) as ?result)
        WHERE {}
    """ .

fn:max
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :arg1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :arg2 ;
                   sh:optional false ; ] ;
    sh:select    """
        SELECT (IF(?arg1 > ?arg2, ?arg1, ?arg2) as ?result)
        WHERE {}
    """ .

fn:pathEquals
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :node1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :path1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    3 ;
                   sh:path     :node2 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    4 ;
                   sh:path     :path2 ;
                   sh:optional false ; ] ;
    sh:prefixes  vf: ;
    sh:select    """
        SELECT ?result
        WHERE {
            ?node1 ?path1 ?value1 .
            ?node2 ?path2 ?value2 .
            BIND(
                IF(ISBLANK(?value1),
                fn:deepPathEquals4(?node1, ?path1, ?node2, ?path2),
                fn:IRIOrLiteralEquals(?value1,?value2)
            )
            as ?result
            )
        }
    """ ;
.

fn:pathEqualsOrBothEmpty
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :node1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :path1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    3 ;
                   sh:path     :node2 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    4 ;
                   sh:path     :path2 ;
                   sh:optional false ; ] ;
    sh:prefixes  vf: ;
    sh:select    """
        SELECT ?result
        WHERE {
            OPTIONAL {
                ?node1 ?path1 ?value1 .
                ?node2 ?path2 ?value2 .
            }
            BIND(
                ( !BOUND(?value1) && !BOUND(?value2) )
                ||
                IF (
                    ISBLANK(?value1),
                    fn:deepPathEquals4(?node1, ?path1, ?node2, ?path2),
                    fn:IRIOrLiteralEquals(?value1,?value2)
                )
            as ?result
            )
        }
    """ ;
.


fn:IRIOrLiteralEquals
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :expected ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :actual ;
                   sh:optional false ; ] ;
    sh:select    """
        SELECT (
                !ISBLANK(?actual)
                && !ISBLANK(?expected)
                && ?actual = ?expected as ?result
            )
        WHERE {}
    """ ;
.

fn:deepPathEquals4
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:order    1 ;
                   sh:path     :node1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    2 ;
                   sh:path     :path1 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    3 ;
                   sh:path     :node2 ;
                   sh:optional false ; ] ;
    sh:parameter [ sh:order    4 ;
                   sh:path     :path2 ;
                   sh:optional false ; ] ;
    sh:select    """
         # TODO: only detects that triples are missing, not when triples were added
         SELECT (COUNT(*) = 0 as ?result)
         WHERE {
            {
                ?node1 ?path1 ?expected .
                ?node2 ?path2 ?actual .
                ?expected ?p ?o .
                OPTIONAL {
                    ?o ?p2 ?o2
                    FILTER (ISBLANK(?o))
                    OPTIONAL {
                        ?o2 ?p3 ?o3
                        FILTER (ISBLANK(?o2))
                        OPTIONAL {
                            ?o3 ?p4 ?o4
                            FILTER (ISBLANK(?o3))
                        }
                    }
                }
                FILTER NOT EXISTS {
                    {
                        ?actual ?p ?o
                        FILTER(!ISBLANK(?o))
                    } UNION {
                        ?actual ?p [
                            ?p2 ?o2
                        ]
                        FILTER(!ISBLANK(?o2))
                    } UNION {
                        ?actual ?p [
                            ?p2 [
                                ?p3 ?o3
                            ]
                        ]
                        FILTER(!ISBLANK(?o3))
                    } UNION {
                        ?actual ?p [
                            ?p2 [
                                ?p3 [
                                    ?p4 ?o4
                                ]
                            ]
                        ]
                        FILTER(!ISBLANK(?o4))
                    }
                }
            } UNION {
                ?node1 ?path1 ?expected .
                ?node2 ?path2 ?actual .
                ?actual ?p ?o .
                OPTIONAL {
                    ?o ?p2 ?o2
                    FILTER (ISBLANK(?o))
                    OPTIONAL {
                        ?o2 ?p3 ?o3
                        FILTER (ISBLANK(?o2))
                        OPTIONAL {
                            ?o3 ?p4 ?o4
                            FILTER (ISBLANK(?o3))
                        }
                    }
                }
                FILTER NOT EXISTS {
                    {
                        ?expected ?p ?o
                        FILTER(!ISBLANK(?o))
                    } UNION {
                        ?expected ?p [
                            ?p2 ?o2
                        ]
                        FILTER(!ISBLANK(?o2))
                    } UNION {
                        ?expected ?p [
                            ?p2 [
                                ?p3 ?o3
                            ]
                        ]
                        FILTER(!ISBLANK(?o3))
                    } UNION {
                        ?expected ?p [
                            ?p2 [
                                ?p3 [
                                    ?p4 ?o4
                                ]
                            ]
                        ]
                        FILTER(!ISBLANK(?o4))
                    }
                }
            }
        }
    """ ;
.


fn:safeStr
    a            sh:SPARQLFunction ;
    sh:parameter [ sh:path     fn:arg1 ;
                   sh:optional false ;
                   sh:order    1 ; ] ;
    sh:parameter [ sh:path     fn:name ;
                   sh:optional true ;
                   sh:datatype xsd:string ;
                   sh:nodeKind sh:Literal ;
                   sh:order    2 ; ] ;
    sh:select    """
        SELECT (
            IF(
                BOUND(?name),
                IF (
                    BOUND(?arg1),
                    STR(?arg1),
                    CONCAT("{?",?name,":unbound}")
                ),
                IF (
                    BOUND(?arg1),
                    STR(?arg1),
                    "{unbound}"
                )
            )
            as ?result
        )
        WHERE {}
    """ .